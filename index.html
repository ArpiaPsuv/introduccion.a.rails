<!DOCTYPE HTML>
<html lang="en-US" manifest="./manifest.appcache">
    <head prefix="og: http://ogp.me/ns# book: http://ogp.me/ns/book#">
        
        <meta charset="UTF-8">
        <title>Introduction | Introducción a Rails</title>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="robots" content="index, follow">
        <meta name="author" content="rubysur">
        <meta name="description" content="Aprende a programar con Ruby">
        <meta name="keywords" content="gitbook,github" >
        <meta name="generator" content="www.gitbook.io">

        
        <link rel="next" href="./capitulos/antes_de_empezar.html" />
        
        

        <meta property="og:title" content="Introduction | Introducción a Rails">
        <meta property="og:site_name" content="Introducción a Rails">
        <meta property="og:type" content="book">
        <meta property="og:locale" content="en_US">

        <meta property="book:author" content="https://github.com/rubysur">
        <meta property="book:tag" content="GitBook">

        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">

        <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">
        
    </head>
    <body>
        

        <link rel="stylesheet" href="gitbook/style.css">
        


        
    <div class="book" data-github="rubysur/introduccion.a.rails" data-level="0" data-basepath="." data-revision="1400882743353">
    <div class="book-header">
    <!-- Actions Left -->
    
    <a href="https://github.com/rubysur/introduccion.a.rails" target="_blank" class="btn pull-left home-bookmark" aria-label="GitHub home"><i class="fa fa-bookmark-o"></i></a>
    
    <a href="#" class="btn pull-left toggle-summary" aria-label="Toggle summary"><i class="fa fa-align-justify"></i></a>
    <a href="#" class="btn pull-left toggle-search" aria-label="Toggle search"><i class="fa fa-search"></i></a>
    <span id="font-settings-wrapper">
        <a href="#" class="btn pull-left toggle-font-settings" aria-label="Toggle font settings"><i class="fa fa-font"></i>
        </a>
        <div class="dropdown-menu font-settings">
    <div class="dropdown-caret">
        <span class="caret-outer"></span>
        <span class="caret-inner"></span>
    </div>

    <div class="btn-group btn-block">
        <button id="reduce-font-size" class="btn btn-default">A</button>
        <button id="enlarge-font-size" class="btn btn-default">A</button>
    </div>

    <ul class="list-group font-family-list">
        <li class="list-group-item" data-font="0">Serif</li>
        <li class="list-group-item" data-font="1">Sans</li>
    </ul>

    <div class="btn-group btn-group-xs btn-block color-theme-list">
        <button type="button" class="btn btn-default" id="color-theme-preview-0" data-theme="0">White</button>
        <button type="button" class="btn btn-default" id="color-theme-preview-1" data-theme="1">Sepia</button>
        <button type="button" class="btn btn-default" id="color-theme-preview-2" data-theme="2">Night</button>
    </div>
</div>

    </span>

    <!-- Actions Right -->
    
    <a href="#" target="_blank" class="btn pull-right google-plus-sharing-link sharing-link" data-sharing="google-plus" aria-label="Share on Google Plus"><i class="fa fa-google-plus"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right facebook-sharing-link sharing-link" data-sharing="facebook" aria-label="Share on Facebook"><i class="fa fa-facebook"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right twitter-sharing-link sharing-link" data-sharing="twitter" aria-label="Share on Twitter"><i class="fa fa-twitter"></i></a>
    

    
    <a href="https://github.com/rubysur/introduccion.a.rails/stargazers" target="_blank" class="btn pull-right count-star hidden-xs"><i class="fa fa-star-o"></i> Star (<span>-</span>)</a>
    <a href="https://github.com/rubysur/introduccion.a.rails/watchers" target="_blank" class="btn pull-right count-watch hidden-xs"><i class="fa fa-eye"></i> Watch (<span>-</span>)</a>
    

    <!-- Title -->
    <h1>
        <i class="fa fa-spinner fa-spin"></i>
        <a href="./" >Introducción a Rails</a>
    </h1>
</div>

    <div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="Search" class="form-control" />
    </div>
    <ul class="summary">
        
        <li>
            <a href="https://github.com/rubysur" target="blank" class="author-link">About the author</a>
        </li>
        

        
        <li>
            <a href="https://github.com/rubysur/introduccion.a.rails/issues" target="blank"class="issues-link">Questions and Issues</a>
        </li>
        

        
        <li>
            <a href="https://github.com/rubysur/introduccion.a.rails/edit/master/README.md" target="blank" class="contribute-link">Edit and Contribute</a>
        </li>
        

        

        <li data-level="0" data-path="index.html">
            <a href="./"><i class="fa fa-check"></i> Introduction</a>
        </li>
        
            <li class="chapter " data-level="1" data-path="capitulos/antes_de_empezar.html">
                
                <a href="./capitulos/antes_de_empezar.html">
                    <i class="fa fa-check"></i> <b>1.</b> Antes de empezar
                </a>
                
                
            </li>
        
            <li class="chapter " data-level="2" data-path="capitulos/que_es_rails.html">
                
                <a href="./capitulos/que_es_rails.html">
                    <i class="fa fa-check"></i> <b>2.</b> ¿Qué es Rails?
                </a>
                
                
            </li>
        
            <li class="chapter " data-level="3" data-path="capitulos/creando_un_nuevo_proyecto/README.html">
                
                <a href="./capitulos/creando_un_nuevo_proyecto/README.html">
                    <i class="fa fa-check"></i> <b>3.</b> Creando un nuevo proyecto
                </a>
                
                
                <ul class="articles">
                    
                        <li  data-level="3.1" data-path="capitulos/creando_un_nuevo_proyecto/instalando_rails.html">
                            
                            <a href="./capitulos/creando_un_nuevo_proyecto/instalando_rails.html">
                                <i class="fa fa-check"></i> <b>3.1.</b> Instalando Rails
                            </a>
                            
                        </li>
                    
                        <li  data-level="3.2" data-path="capitulos/creando_un_nuevo_proyecto/creando_la_aplicacion.html">
                            
                            <a href="./capitulos/creando_un_nuevo_proyecto/creando_la_aplicacion.html">
                                <i class="fa fa-check"></i> <b>3.2.</b> Creando la aplicación
                            </a>
                            
                        </li>
                    
                </ul>
                
            </li>
        
            <li class="chapter " data-level="4" data-path="capitulos/hola_rails/README.html">
                
                <a href="./capitulos/hola_rails/README.html">
                    <i class="fa fa-check"></i> <b>4.</b> Hola, Rails!
                </a>
                
                
                <ul class="articles">
                    
                        <li  data-level="4.1" data-path="capitulos/hola_rails/iniciando_el_servidor.html">
                            
                            <a href="./capitulos/hola_rails/iniciando_el_servidor.html">
                                <i class="fa fa-check"></i> <b>4.1.</b> Iniciando el servidor
                            </a>
                            
                        </li>
                    
                        <li  data-level="4.2" data-path="capitulos/hola_rails/hola_mundo.html">
                            
                            <a href="./capitulos/hola_rails/hola_mundo.html">
                                <i class="fa fa-check"></i> <b>4.2.</b> Hola Mundo
                            </a>
                            
                        </li>
                    
                        <li  data-level="4.3" data-path="capitulos/hola_rails/hola_mundo.html">
                            
                            <a href="./capitulos/hola_rails/hola_mundo.html">
                                <i class="fa fa-check"></i> <b>4.3.</b> Estableciendo la página principal
                            </a>
                            
                        </li>
                    
                </ul>
                
            </li>
        
            <li class="chapter " data-level="5" data-path="capitulos/que_sigue.html">
                
                <a href="./capitulos/que_sigue.html">
                    <i class="fa fa-check"></i> <b>5.</b> ¿Qué sigue?
                </a>
                
                
            </li>
        

        
        <li class="divider"></li>
        <li>
            <a href="http://www.gitbook.io/" target="blank" class="gitbook-link">Generated using GitBook</a>
        </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="page-wrapper" tabindex="-1">
                <div class="book-progress">
    <div class="bar">
        <div class="inner" style="width: 0%;min-width: 0%;"></div>
    </div>
    <div class="chapters">
    
        <a href="./index.html" title="Introduction" class="chapter done new-chapter" data-progress="0" style="left: 0%;"></a>
    
        <a href="./capitulos/antes_de_empezar.html" title="Antes de empezar" class="chapter  new-chapter" data-progress="1" style="left: 11.11111111111111%;"></a>
    
        <a href="./capitulos/que_es_rails.html" title="¿Qué es Rails?" class="chapter  new-chapter" data-progress="2" style="left: 22.22222222222222%;"></a>
    
        <a href="./capitulos/creando_un_nuevo_proyecto/README.html" title="Creando un nuevo proyecto" class="chapter  new-chapter" data-progress="3" style="left: 33.333333333333336%;"></a>
    
        <a href="./capitulos/creando_un_nuevo_proyecto/instalando_rails.html" title="Instalando Rails" class="chapter  " data-progress="3.1" style="left: 44.44444444444444%;"></a>
    
        <a href="./capitulos/creando_un_nuevo_proyecto/creando_la_aplicacion.html" title="Creando la aplicación" class="chapter  " data-progress="3.2" style="left: 55.55555555555556%;"></a>
    
        <a href="./capitulos/hola_rails/README.html" title="Hola, Rails!" class="chapter  new-chapter" data-progress="4" style="left: 66.66666666666667%;"></a>
    
        <a href="./capitulos/hola_rails/iniciando_el_servidor.html" title="Iniciando el servidor" class="chapter  " data-progress="4.1" style="left: 77.77777777777777%;"></a>
    
        <a href="./capitulos/hola_rails/hola_mundo.html" title="Estableciendo la página principal" class="chapter  " data-progress="4.3" style="left: 88.88888888888889%;"></a>
    
        <a href="./capitulos/que_sigue.html" title="¿Qué sigue?" class="chapter  new-chapter" data-progress="5" style="left: 100%;"></a>
    
    </div>
</div>

                <div class="page-inner">
                
                    <section class="normal" id="section-gitbook_2">
                    
                        <h1 id="introducci-n-a-rails">Introducción a Rails</h1>
<p>Este proyecto nace con la idea de traducir al español la guía oficial
<a href="http://guides.rubyonrails.org/getting_started.html" target="_blank">&quot;Getting Started with Rails&quot;</a>.</p>
<p>Esta guía cubre ¿cómo comenzar con Ruby on Rails? Luego de leerla, aprenderás
lo siguiente:</p>
<ul>
<li>Instalar Rails, crear una nueva aplicación Rails y conectar tu aplicación a
una base de datos.</li>
<li>La estructura general de una aplicación Rails.</li>
<li>Los principios básicos del patrón MVC (Modelo, Vista, Controlador) y
Diseño RESTful.</li>
<li>Como generar rápidamente las primeras piezas de una aplicación Rails.</li>
</ul>
<blockquote>
<p><strong>Nota:</strong> Esta guía está basada en Rails 3.2. Algunas partes del código que
se muestran aquí no van a funcionar en nuevas versiones de Rails.</p>
</blockquote>
<h2 id="poniendo-todo-en-funcionamiento">Poniendo todo en funcionamiento</h2>
<p>Ahora que has visto como crear un controlador, una acción y una vista, vamos a crear
algo con un poco más de sentido.</p>
<p>En la aplicación de Blog, tú vas a crear un nuevo recurso (<em>resource</em>). Un recurso
es el término usado para una colección de objetos similares, como posts, personas o
animales. Tú puedes crear, leer, actualizar y eliminar objetos para un recurso
y estas operaciones son referedidas como operaciones <em>CRUD</em>.</p>
<p>En la siguiente sección, tú añadirás la habilidad de crear nuevos posts en tu aplicación
y poder verlos también. Ésto es la &quot;C&quot; y la &quot;R&quot; de <em>CRUD</em>: creación y lectura. La manera
de hacer esto se vería de la siguiente manera:</p>
<p><img src="http://edgeguides.rubyonrails.org/images/getting_started/new_post.png" alt="The new post form"></p>
<p>Se ve un poco básico por ahora, pero está bien. Ya veremos como mejorar el estilo.</p>
<h2 id="estableciendo-la-base">Estableciendo la base</h2>
<p>La primera cosa que necesitaremos para crear un nuevo post, es crear un espacio para hacer eso
en nuestra aplicación. Un buen lugar podría ser <code>/posts/new</code>. Si tratas de navegar a esa
dirección ahora -- visitando <a href="http://localhost:3000/posts/new" target="_blank">http://localhost:3000/posts/new</a> -- Rails te dará un error de
ruteo:</p>
<p><img src="http://edgeguides.rubyonrails.org/images/getting_started/routing_error_no_route_matches.png" alt="A routing error, no route matches /posts/new"></p>
<p>Esto es porque no en ningún lugar dentro de las rutas para la aplicación -- definidas dentro
de <code>config/routes.rb</code> -- que defina esta ruta. Por defecto, Rails no tiene rutas configuradas,
excepto por la ruta <code>root</code> que definimos anteriormente, es por esto que tú tendrás que definir
tus rutas cuando las necesites.</p>
<p>Para hacer esto, vas a necesitar crear una ruta dentro de el archivo <code>config/routes.rb</code>, en
una nueva línea entre el <code>do</code> y el <code>end</code> del método <code>draw</code>:</p>
<pre><code class="lang-ruby">get <span class="hljs-string">"posts/new"</span>
</code></pre>
<p>Esta ruta es super simple: define una nueva ruta que sólo responderá a peticiones <code>GET</code>, y qye
la ruta se encuentra en <code>posts/new</code>. Pero como sabe a donde ir sin haber usado la opción
<code>:to</code>? Bueno, Rails usa una convención sensible aquí: Rails asumirá que lo que tú quieres
es que esta ruta vaya a la acción <code>new</code> dentro de el controlador <code>posts</code>.</p>
<p>Con esta ruta definidad, tus peticiones ahora se pueden hacer a través de <code>/posts/new</code> en
la aplicación. Navega hacia: <a href="http://localhost:3000/posts/new" target="_blank">http://localhost:3000/posts/new</a>. Verás otro error de ruteo:</p>
<p><img src="http://edgeguides.rubyonrails.org/images/getting_started/routing_error_no_controller.png" alt="Another routing error, uninitialized constant PostsController"></p>
<p>Este error está pasando porque esta ruta necesita un controlador que esté definido. La ruta
está tratando de encontrar el controlador para servir la petición, pero con el controlador
no definido, simplemente no lo puede hacer. La solución para este caso en particular es simple:
crea un controlador llamado <code>PostsController</code>. Puedes hacerlo ejecutando el siguiente comando:</p>
<pre><code class="lang-bash">$ rails g controller posts
</code></pre>
<p>Si abres el nuevo archivo generado <code>app/controllers/posts_controller.rb</code>,
verás un controlador vacío:</p>
<pre><code class="lang-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostsController</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">ApplicationController</span></span></span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Un controlador es simplemente una clase que es definida para heredar de <code>ApplicationController</code>.
Dentro de ésta, vas a definir los métodos que se convertirán en acciones para este controlador.
Estas acciones van a ejecutar operaciones <em>CRUD</em> sobre los posts dentro de nuestro sistema.</p>
<p>Si refrescas la dirección <a href="http://localhost:3000/posts/new" target="_blank">http://localhost:3000/posts/new</a> ahora, vas a tener un nuevo error:</p>
<p><img src="http://edgeguides.rubyonrails.org/images/getting_started/unknown_action_new_for_posts.png" alt="Unknown action new for PostsController!"></p>
<p>Este error indica que Rails no puede encontrar la acción <code>new</code> dentro de
<code>PostsController</code> que recién has generado. Esto es porque cuando los controladores
son generados en Rails están vacíos por defecto, a menos que le digas que acciones
quieres durante el proceso de generación.</p>
<p>Para definir manualmente una acción dentro de un controlador, todo lo que necesitas
es definir un nuevo método dentro del controlador. Abre <code>app/controllers/posts_controller.rb</code>
y dentro de la clase <code>PostsController</code>, define el método <code>new</code> así:</p>
<pre><code class="lang-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> </span>new
<span class="hljs-keyword">end</span>
</code></pre>
<p>Con el método <code>new</code> definido en <code>PostsController</code>, si tú refrescas
<a href="http://localhost:3000/posts/new" target="_blank">http://localhost:3000/posts/new</a> verás otro error:</p>
<p><img src="http://edgeguides.rubyonrails.org/images/getting_started/template_is_missing_posts_new.png" alt="Template is missing for posts/new"></p>
<p>Estás obteniendo este error ahora porque Rails espera que las acciones planas
como ésta tengan vistas asociadas a ellas para mostrar la información. Con ninguna
vista disponible, Rails mostrará un error.</p>
<p>En la imagen de arriba, la línea de abajo fue eliminada. Vamos a ver como se ve el error completo:</p>
<blockquote>
Missing template posts/new, application/new with {:locale=&gt;[:en], :formats=&gt;[:html], :handlers=&gt;[:erb, :builder, :coffee]}. Searched in: * &quot;/path/to/blog/app/views&quot;
</blockquote>

<p>Eso es casi un montón de texto! Revisemos rápidamente para entender cuál es la función de cada parte.</p>
<p>La primera parte identifica que plantilla está faltando. En este caso, es la plantila <code>posts/new</code>.
Rails primero buscará esta plantilla. Si no la encuentra, luego tratará de cargar la plantilla
llamada <code>application/new</code>. Busca una aquí porque el <code>PostsController</code> hereda de <code>ApplicationController</code>.</p>
<p>La siguiente parte del mensaje contiene un map (<code>hash</code> en inglés). La llave <code>:locale</code> en este map
simplemente indica el lenguaje que debe contener la plantilla solicitada. Por defecto, está configurado
en Inglés -- o &quot;en&quot; --. La siguiente llave, <code>:formats</code> especifica el formato de la plantilla que será
servido en la respuesta. El formato por defecto es <code>:html</code>, es por eso que Rails busca una plantilla
HTML. La llave final, <code>:handlers</code>, nos dice que <em>manejador de plantilla</em> (o <em>template handler</em> en inglés)
puede ser usada para producir nuestra plantilla. <code>:erb</code> es el manejador más usado para plantillas HTML,
<code>:builder</code> es usado para plantillas XML, y <code>:coffee</code> usa CoffeeScript para construir plantillas JavaScript.</p>
<p>La más simple plantilla que funcionaría en nuestro caso sería una localizada en <code>app/views/posts/new.html.erb</code>.
La extensión de este nombre de archivo es importante: la primera extensión define el <em>formato</em> de la plantilla,
y la segunda extensión el <em>manejador de plantilla</em> que será usado. Rails está tratando de encontrar una
plantilla llamada <code>posts/new</code> en <code>app/views</code> para la aplicación. El formato para esta plantilla puede sólo
ser <code>html</code> y el manejador debería ser <code>erb</code>, <code>builder</code> o <code>coffee</code>. Ya que tú quieres crear un nuevo
formulario HTML, tú tendrás que usar el lenguaje <code>ERB</code>. Por lo tanto el archivo debería ser llamado
<code>posts/new.html.erb</code> y necesita ser localizado dentro de la carpeta <code>app/views</code> de la aplicación.</p>
<p>Ahora ve y crea un nuevo archivo en <code>app/views/posts/new.html.erb</code> y escribe el siguiente
contenido en él:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span>New Post<span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>
</code></pre>
<p>Cuando refresques <a href="http://localhost:3000/posts/new" target="_blank">http://localhost:3000/posts/new</a>, verás que la página tiene un título. La ruta,
el controlador, la acción y la vista ahora están funcionando de manera armoniosa! Es hora de crear
el formulario para un nuevo post.</p>
<h2 id="el-primer-formulario">El primer formulario</h2>
<p>Para crear una formulario con esta plantilla usarás un <em>constructor de formularios</em> (o <em>form builder</em>
en inglés). El form builder primario de Rails está provisto por un método de ayuda llamado <code>form_for</code>.
Para usar este método agrega este código a <code>app/views/posts/new.html.erb</code>:</p>
<pre><code class="lang-html+erb">&lt;%= form_for :post do |f| %&gt;
  &lt;p&gt;
    &lt;%= f.label :title %&gt;&lt;br&gt;
    &lt;%= f.text_field :title %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= f.label :text %&gt;&lt;br&gt;
    &lt;%= f.text_area :text %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= f.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;
</code></pre>
<p>Si refrescas la página ahora, verás el mismo formulario que en el ejemplo.
Construir un formulario en Rails es así de sencillo!</p>
<p>Cuando llamas a <code>form_for</code>, le pasas un objeto identificador para este
formulario. En este caso, es el símbolo <code>:post</code>. Esto le indica al método
<code>form_for</code> para quién es este formulario. Dentro del bloque para este método,
el objeto <code>FormBuilder</code> - representado por <code>f</code> - es usado para construir dos
etiquetas y dos cajas de texto, una de cada una para el título y el texto del
post. Finalmente, la llamada al método <code>submit</code> en el objeto <code>f</code> creará un
botón de submit en el formulario.</p>
<p>Sin embargo, existe un problema con este formulario. Si inspeccionas el código
HTML generado, al ver la fuente de la página, verás que el atributo <code>action</code> de
el formulario apunta a <code>/posts/new</code>. Ésto es un problema debido a que esta ruta
va a la misma página donde te encuentras en este momento cuando en realidad la
ruta debería sólo ser usada para mostrar el formulario para un nuevo post.</p>
<p>El formulario necesita usar un URL distinto para poder dirigirse hacia algún otro
lugar. Ésto puede hacerse, de manera bastante sencilla, con la opción <code>:url</code> de
<code>form_for</code>. En Rails la acción que se usa típicamente para nuevas entradas es llamada
&quot;create&quot; (crear en español) por lo que el formulario debería ser apuntado hacia
esa acción.</p>
<p>Edita la linea de <code>form_for</code> siguiente: <code>app/views/posts/new.html.erb</code> para que
se vea así:</p>
<pre><code class="lang-html+erb">&lt;%= form_for :post, :url =&gt; { :action =&gt; :create } do |f| %&gt;
</code></pre>
<p>En este ejemplo un objeto <code>Hash</code> es pasado a la opción <code>:url</code>. Lo que Rails hará con
esto es apuntar el formulario a la acción <code>create</code> del controlador actual, el <code>PostsController</code>.
y enviará una petición de <code>POST</code> hacia esa ruta. Para que esto funcione necesitarás añadir
una ruta a <code>config/routes.rb</code>, justo debajo de la de &quot;post/new&quot;:</p>
<pre><code class="lang-ruby">post <span class="hljs-string">"posts"</span> =&gt; <span class="hljs-string">"posts#create"</span>
</code></pre>
<p>Al usar el método <code>post</code> en vez de <code>get</code>, Rails definirá una ruta que solo responderá a metodos POST.
El método POST es el método típico utilizado por todos los formularios a lo largo de la red.</p>
<p>Con el formulario y su ruta asociada definidas, serás capaz de llenar el formulario y dar click en el
botón de submit para empezar el proceso de creación de un nuevo post, así que ve y haz eso. Cuando
des click al botón y envíes el formulario, te encontrarás con un error familiar.</p>
<p><img src="http://edgeguides.rubyonrails.org/images/getting_started/unknown_action_create_for_posts.png" alt="Unknown action create for PostsController"></p>
<p>Ahora necesitas crear la acción <code>create</code> en <code>PostsController</code> para que funcione.</p>
<h3 id="creando-art-culos">Creando artículos</h3>
<p>Para hacer que &quot;Unknown action&quot; desaparezca, puedes definir una acción <code>create</code>
dentro de la clase <code>PostsController</code> en <code>app/controllers/posts_controller.rb</code>, debajo de la acción <code>new</code>:</p>
<pre><code class="lang-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostsController</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">ApplicationController</span></span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> </span>new
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> </span>create
  <span class="hljs-keyword">end</span>

<span class="hljs-keyword">end</span>
</code></pre>
<p>Si reenvías el formulario ahora, verás otro error común: falta una plantilla. Está bien, vamos a ignorar
eso por ahora. Lo que la acción <code>create</code> debe hacer es salvar el nuevo artículo en la base de datos.</p>
<p>Cuando un formulario es enviado, los campos del formulario son enviados a Rails como <em>parámetros</em>. Estos
parámetros pueden ser referenciados dentro de las acciones del controlador, generalmente para realizar una
tarea determinada. Para ver que hacen estos parámetros, cambiar la acción <code>create</code> a esto:</p>
<pre><code class="lang-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> </span>create
  render <span class="hljs-symbol">:text</span> =&gt; params[<span class="hljs-symbol">:post</span>].inspect
<span class="hljs-keyword">end</span>
</code></pre>
<p>El método <code>render</code> toma un simple hash con la clave <code>text</code> y el valor de <code>params[:post].inspect</code>. El
método <code>params</code> es el objeto que representa a los parámetros (o campos) que vienen desde el formulario.
El método <code>params</code> retorna un objeto <code>HashWithIndifferentAccess</code>, que te permite acceder a las claves del hash
usando cadenas o símbolos. En esta situación los únicos parámetros que importan son los que vienen del
formulario.</p>
<p>Si reenvias el formulario una vez más, ya no obtendrás el error de plantilla faltante, en su lugar verás
algo como lo que sigue:</p>
<pre><code class="lang-ruby">{<span class="hljs-string">"title"</span>=&gt;<span class="hljs-string">"First post!"</span>, <span class="hljs-string">"text"</span>=&gt;<span class="hljs-string">"This is my first post."</span>}
</code></pre>
<p>Esta acción muestra ahora los parámetros para el artículo que están llegando desde el formulario. Sin
embargo, esto no es realmente útil. Sí, puedes ver los parámetros, pero no hay nada en particular que se
está haciendo con ellos.</p>
<h3 id="creando-el-modelo-post">Creando el modelo post</h3>
<p>Los modelos en Rails usan un nombre en singular, y sus correspondientes tablas
de base de datos usan un nombre en plural. Rails provee un generador para crear
modelos, el cual la mayoría de desarrolladores en Rails tienden a usar para
crear nuevos modelos:</p>
<pre><code class="lang-bash">$ rails generate model Post title:string text:text
</code></pre>
<p>Con ese comando le decimos a Rails que nosotros queremos un modelo <code>Post</code>,
junto con un atributo <em>title</em> de tipo <em>string</em>, y un atributo <em>texto</em> de tipo
<em>text</em>. Esos atributos son automáticamente añadidos a la tabla <code>posts</code> en la
base de datos y mapeados al modelo <code>Post</code>.</p>
<p>Rails respondió con la creación de un montón de archivos. Por ahora, nosotros
sólo estamos interesados en <code>app/models/post.rb</code> y
<code>db/migrate/20120419084633_create_posts.rb</code> (en tu caso puede ser un poco
diferente). Este último es responsable de crear la estructura de la base
de datos, que es lo que revisaremos luego.</p>
<p>CONSEJO: Active Record es lo suficientemente inteligente para asignar
automáticamente el nombre de las columnas a atributos del modelo,
lo que significa que tú no tienes que declarar los atributos dentro
de los modelos de Rails, ya que será realizado automáticamente por
Active Record.</p>
<h3 id="ejecutando-una-migraci-n">Ejecutando una migración</h3>
<p>Como hemos visto, <code>rails generate model</code> crea un archivo <em>database
migration</em> dentro del directorio <code>db/migrate</code>.
Migraciones son clases de Ruby que están diseñadas para hacer simple la
creación y modificación de las tablas de la base de datos. Rails usa comandos rake
para ejecutar migraciones, y es posible deshacer una migración despues que ha sido aplicada
a la base de datos. Archivo de migraciones incluyen una marca de la fecha y hora para
que sean procesadas en el orden que fueron creadas.</p>
<p>Si miras dentro del archivo <code>db/migrate/20120419084633_create_posts.rb</code> (recuerda,
tu archivo puede tener un nombre ligeramente diferente), esto es lo que encontrarás:</p>
<pre><code class="lang-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePosts</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">ActiveRecord::Migration</span></span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> </span>change
    create_table <span class="hljs-symbol">:posts</span> <span class="hljs-keyword">do</span> |t|
      t.string <span class="hljs-symbol">:title</span>
      t.text <span class="hljs-symbol">:text</span>

      t.timestamps
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>La migración de arriba crea un método llamado <code>change</code> el cual será llamado cuando ejecutes
la migración. La acción definida en este método es reversible, lo cual significa que Rails
conoce como deshacer los cambios realizados en esta migración en caso que necesites hacer eso
más tarde. Cuando ejecutas esta migración se creará una tabla <code>post</code> con una columna tipo <code>string</code>
y otra columna tipo <code>text</code>. También crea dos campos de fecha-hora para permitir a Rails realizar
un seguimiento de las actualizaciones. Mayor información acerca de las migraciones en Rails
pueden ser encontradas en la guía <a href="http://guides.rubyonrails.org/migrations.html" target="_blank">Rails Database Migrations</a>.</p>
<p>En este punto, puedes usar el comando rake para ejecutar la migración:</p>
<pre><code class="lang-bash">$ rake db:migrate
</code></pre>
<p>Rails ejecutará este comando de migración y te responderá lo siguiente cuando haya
creado la tabla <code>Posts</code>.</p>
<pre><code class="lang-bash">==  CreatePosts: migrating ====================================================
-- create_table(:posts)
   -&gt; <span class="hljs-number">0.0019</span>s
==  CreatePosts: migrated (<span class="hljs-number">0.0020</span>s) ===========================================
</code></pre>
<blockquote>
<p><strong>Nota:</strong> Debido a que estás trabajando en el ambiente de desarrollo por omisión,
este comando se aplicará a la base de datos definida en la sección <code>development</code>
de tu archivo <code>config/database.yml</code>. Si deseas ejecutar migraciones en otro
ambiente, por ejemplo en producción, debes indicarlo en forma explícita cuando
invoques el comando: <code>rake db:migrate RAILS_ENV=production</code>.</p>
</blockquote>
<h3 id="salvando-datos-en-el-controlador">Salvando datos en el controlador</h3>
<p>En <code>posts_controller</code> necesitamos cambiar la acción <code>create</code> para usar el nuevo modelo <code>Post</code>
y guardar los datos en la base de datos. Abra el archivo y cambie la acción <code>create</code>
que debe verse de la siguiente manera:</p>
<pre><code class="lang-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> </span>create
  <span class="hljs-variable">@post</span> = <span class="hljs-constant">Post</span>.new(params[<span class="hljs-symbol">:post</span>])

  <span class="hljs-variable">@post</span>.save
  redirect_to <span class="hljs-symbol">:action</span> =&gt; <span class="hljs-symbol">:show</span>, <span class="hljs-symbol">:id</span> =&gt; <span class="hljs-variable">@post</span>.id
<span class="hljs-keyword">end</span>
</code></pre>
<p>Esto es lo que sucede: cada modelo Rails puede ser inicializado con sus respectivos
atributos, los cuales son automáticamente asignados a sus respectivas columnas de
base de datos. En la primera línea hacemos justamente eso (recuerda que
<code>params[:post]</code> contiene los atributos en los cuales estamos interesados). Luego,
<code>@post.save</code> es responsable de guardar el modelo en la base de datos. Finalmente,
direccionamos al usuario a la acción <code>show</code> que definiremos más tarde.</p>
<p>CONSEJO: Como veremos más tarde, <code>@post.save</code> devuelve un indicador que indica si el
modelo fue guardado o no.</p>
<h3 id="mostrando-art-culos">Mostrando artículos</h3>
<p>Si envías el formulario de nuevo, Rails se quejará que no has definido la acción <code>show</code>.
Esto no es muy útil así que vamos a agregar la acción <code>show</code> antes de continuar. Abra
el archivo <code>config/routes.rb</code> y agregue la siguiente ruta:</p>
<pre><code class="lang-ruby">get <span class="hljs-string">"posts/:id"</span> =&gt; <span class="hljs-string">"posts#show"</span>
</code></pre>
<p>La sintaxis especial <code>:id</code> le dice a Rails que la ruta espera un parámetro <code>:id</code>,
el cual en nuestro caso será el id del artículo. Note que en esta ocasión
debemos indicar la asignación real <code>posts#show</code> porque de otra manera Rails no sabrá
que acción debe realizar.</p>
<p>Como dijimos anteriormente, necesitamos agregar la acción <code>show</code> en el <code>posts_controller</code>
y su respectiva vista.</p>
<pre><code class="lang-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> </span>show
  <span class="hljs-variable">@post</span> = <span class="hljs-constant">Post</span>.find(params[<span class="hljs-symbol">:id</span>])
<span class="hljs-keyword">end</span>
</code></pre>
<p>Un par de cosas a tener en cuenta. Usamos <code>Post.find</code> para encontrar el artículo en el
cual estamos interesados. También usamos una variable de instancia (con el prefijo @)
para contener una referencia al objeto <code>post</code>. Hacemos eso porque Rails pasará todas
las variables de instancia a la vista.</p>
<p>Ahora, crea un nuevo archivo <code>app/view/posts/show.html.erb</code> con el siguiente contenido:</p>
<pre><code class="lang-html+erb">&lt;p&gt;
  &lt;strong&gt;Title:&lt;/strong&gt;
  &lt;%= @post.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Text:&lt;/strong&gt;
  &lt;%= @post.text %&gt;
&lt;/p&gt;
</code></pre>
<p>Finalmente, si vas a
<a href="http://localhost:3000/posts/new" target="_blank">http://localhost:3000/posts/new</a> serás capaz de
crear un artículo. ¡Inténtalo!</p>
<p><img src="http://edgeguides.rubyonrails.org/images/getting_started/show_action_for_posts.png" alt="Show action for posts"></p>
<h3 id="listando-todos-los-art-culos">Listando todos los artículos</h3>
<p>Aún necesitamos una forma de listar todos los artículos, de manera que vamos a hacerlo.
Como de costumbre, vamos a necesitar una ruta ubicada dentro de <code>config/routes.rb</code>:</p>
<pre><code class="lang-ruby">get <span class="hljs-string">"posts"</span> =&gt; <span class="hljs-string">"posts#index"</span>
</code></pre>
<p>Y una acción para esa ruta dentro de <code>PostsController</code> en el archivo <code>app/controllers/posts_controller.rb</code>:</p>
<pre><code class="lang-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> </span>index
  <span class="hljs-variable">@posts</span> = <span class="hljs-constant">Post</span>.all
<span class="hljs-keyword">end</span>
</code></pre>
<p>Y finalmente una vista para esta acción, ubicada en <code>app/views/posts/index.html.erb</code>:</p>
<pre><code class="lang-html+erb">&lt;h1&gt;Listing posts&lt;/h1&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Title&lt;/th&gt;
    &lt;th&gt;Text&lt;/th&gt;
  &lt;/tr&gt;

  &lt;% @posts.each do |post| %&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;%= post.title %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%= post.text %&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;% end %&gt;
&lt;/table&gt;
</code></pre>
<p>Ahora si vamos a <code>http://localhost:3000/posts</code> veremos una lista con todos los artículos que has creado.</p>
<h3 id="agregando-enlaces">Agregando enlaces</h3>
<p>Hasta el momento puedes crear, mostrar y listar artículos. Ahora vamos a agregar
algunos enlaces para navegar a través de las páginas.</p>
<p>Abra <code>app/views/welcome/index.html.erb</code> y modifiquelo como se indica a continuación:</p>
<pre><code class="lang-html+erb">&lt;h1&gt;Hello, Rails!&lt;/h1&gt;
&lt;%= link_to &quot;My Blog&quot;, :controller =&gt; &quot;posts&quot; %&gt;
</code></pre>
<p>El método <code>link_to</code> es uno de los asistentes de la vista incorporados en Rails. Este método crea el
hipervínculo mostrando un texto e indicando donde irá, en este caso a la ubicación <code>post</code>.</p>
<p>Vamos a agregar enlaces a las otras vistas, empezando por agregar a &quot;New Post&quot; el enlace a
<code>app/views/posts/index.html.erb</code>, ubicándola encima de <code>&lt;!-- &lt;table&gt; --&gt;</code> tag:</p>
<pre><code class="lang-erb">&lt;%= link_to &#39;New post&#39;, :action =&gt; :new %&gt;
</code></pre>
<p>Este enlace te permitirá abrir el formulario para crear un nuevo artículo. También deberías
agregar un enlace a esta plantilla -- <code>app/views/posts/new.html.erb</code> -- para regresar a la
acción <code>index</code>. Para hacer eso agregue el enlace debajo del formulario en esta plantilla:</p>
<pre><code class="lang-erb">&lt;%= form_for :post do |f| %&gt;
  ...
&lt;% end %&gt;

&lt;%= link_to &#39;Back&#39;, :action =&gt; :index %&gt;
</code></pre>
<p>Finalmente, agregue otro enlace a la plantilla <code>app/views/posts/show.html.erb</code> para regresar
a la acción <code>index</code>, de manera que la persona que está viendo un artículo pueda regresar
y ver la lista completa nuevamente.</p>
<pre><code class="lang-html+erb">&lt;p&gt;
  &lt;strong&gt;Title:&lt;/strong&gt;
  &lt;%= @post.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Text:&lt;/strong&gt;
  &lt;%= @post.text %&gt;
&lt;/p&gt;

&lt;%= link_to &#39;Back&#39;, :action =&gt; :index %&gt;
</code></pre>
<p>CONSEJO: Si deseas crear un enlace a una acción dentro del mismo controlador
no necesitas especificar la opción <code>:controller</code>, Rails usará el actual
controlador por omisión.</p>
<p>CONSEJO: En modo de desarrollo (en la cual estás trabajdo por omisión), Rails recarga
tu aplicación en cada requerimiento del navegador, por lo que no hay necesidad de
reiniciar el servidor web cuando un cambio es realizado.</p>
<h3 id="permitiendo-la-actualizaci-n-de-campos">Permitiendo la actualización de campos</h3>
<p>El archivo del modelo <code>app/models/post.rb</code> es tan simple como:</p>
<pre><code class="lang-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Post</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">ActiveRecord::Base</span></span></span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>No hay mucho en ese archivo - pero noten que la clase <code>Post</code> hereda de
<code>ActiveRecord::Base</code>. Active Record provee una gran cantidad de funcionalidad a los
modelos de Rails de forma sencilla, incluyendo las operaciones básicas CRUD (del
inglés Create, Read, Update, Destroy) de base de datos, validación de datos así
como el soporte a búsquedas sofisticadas y la habilidad de relacionar múltiples
modelos entre sí.</p>
<p>Rails incluye métodos que ayudaran a asegurar los campos de tu modelo.
Abra el archivo <code>app/models/post.rb</code> y complete según se indica:</p>
<pre><code class="lang-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Post</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">ActiveRecord::Base</span></span></span>
  attr_accessible <span class="hljs-symbol">:text</span>, <span class="hljs-symbol">:title</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Este cambio asegura que todos los cambios realizados a través de formularios HTML
puedan editar los campos <code>text</code> y <code>title</code>.
No será posible definir la edición de otro campo diferente a través de formularios.
Por supuesto aún será posible definirlo usando el método <code>field=</code>.
La accesibilidad de los atributos y el problema de la asignación masiva es cubierto
en detalle en <a href="http://guides.rubyonrails.org/security.html" target="_blank">Security guide</a>.</p>
<h3 id="agregando-algunas-validaciones">Agregando algunas validaciones</h3>
<p>Rails incluye métodos para ayudarte a validar los datos que son enviados a los modelos.
Abre el archivo <code>app/models/post.rb</code> y editalo de la siguiente manera:</p>
<pre><code class="lang-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Post</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">ActiveRecord::Base</span></span></span>
  attr_accessible <span class="hljs-symbol">:text</span>, <span class="hljs-symbol">:title</span>

  validates <span class="hljs-symbol">:title</span>, <span class="hljs-symbol">:presence</span> =&gt; <span class="hljs-keyword">true</span>,
                    <span class="hljs-symbol">:length</span> =&gt; { <span class="hljs-symbol">:minimum</span> =&gt; <span class="hljs-number">5</span> }
<span class="hljs-keyword">end</span>
</code></pre>
<p>Estos cambios asegurarán que todos los artículos tengan un título que sea al menos de cinco caracteres
de longitud. Rails puede validar una variedad de condiciones en un modelo, incluyendo la presencia o
la unicidad de columnas, sus formatos y la existencia de objetos asociados. Las validaciones están cubiertas
en detalle en <a href="http://edgeguides.rubyonrails.org/active_record_validations_callbacks.html" target="_blank">Active Record Validations and Callbacks</a>.</p>
<p>Con la validaciones agregadas, cuando llames a <code>@post.save</code> en un artículo inválido
retornará <code>false</code>. Si abres el archivo <code>app/controllers/posts_controller.rb</code>
otra vez, notarás que no verificamos el resultado de la llamada <code>@post.save</code>
dentro de la acción <code>create</code>. Si <code>@post.save</code> falla en esta situación, necesitamos mostrar
el formulario de regreso al usuario. Para hacer esto, cambiar las acciones <code>new</code> y <code>create</code>
dentro de <code>app/controllers/posts_controller.rb</code> a esto:</p>
<pre><code class="lang-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> </span>new
  <span class="hljs-variable">@post</span> = <span class="hljs-constant">Post</span>.new
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> </span>create
  <span class="hljs-variable">@post</span> = <span class="hljs-constant">Post</span>.new(params[<span class="hljs-symbol">:post</span>])

  <span class="hljs-keyword">if</span> <span class="hljs-variable">@post</span>.save
    redirect_to <span class="hljs-symbol">:action</span> =&gt; <span class="hljs-symbol">:show</span>, <span class="hljs-symbol">:id</span> =&gt; <span class="hljs-variable">@post</span>.id
  <span class="hljs-keyword">else</span>
    render <span class="hljs-string">'new'</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>La acción <code>new</code> está ahora creando una nueva instancia llamada <code>@post</code>,
y verás el motivo de ello en un momento.</p>
<p>Notas que dentro de la acción <code>create</code> usamos <code>render</code>en lugar de <code>redirect_to</code> cuando acción <code>save</code>
retorna <code>false</code>. El método <code>render</code>es usado de manera que el objeto <code>@post</code>es regresado a la plantilla
<code>new</code> cuando es interpretado. Esta interpretación se hace dentro de la misma solicitud que hace el envío
del formulario, mientras que <code>redirect_to</code>le dirá al navegador para emitir una nueva solicitud.</p>
<p>Si recargas <a href="http://localhost:3000/posts/new" target="_blank">http://localhost:3000/posts/new</a> y
tratas de guardar un artículo sin título, Rails enviará de regreso un formulario
pero que no es muy útil. Necesitas decirle al usuario que algo está mal.
Para hacer esto hay que modificar el archivo<code>app/views/posts/new.html.erb</code>
para verificar los mensajes de error:</p>
<pre><code class="lang-html+erb">&lt;%= form_for :post, :url =&gt; { :action =&gt; :create } do |f| %&gt;
  &lt;% if @post.errors.any? %&gt;
  &lt;div id=&quot;errorExplanation&quot;&gt;
    &lt;h2&gt;&lt;%= pluralize(@post.errors.count, &quot;error&quot;) %&gt; prohibited
      this post from being saved:&lt;/h2&gt;
    &lt;ul&gt;
    &lt;% @post.errors.full_messages.each do |msg| %&gt;
      &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
    &lt;% end %&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
  &lt;% end %&gt;
  &lt;p&gt;
    &lt;%= f.label :title %&gt;&lt;br&gt;
    &lt;%= f.text_field :title %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= f.label :text %&gt;&lt;br&gt;
    &lt;%= f.text_area :text %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= f.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;

&lt;%= link_to &#39;Back&#39;, :action =&gt; :index %&gt;
</code></pre>
<p>Veamos que está pasando. Verificamos si hay errores con
<code>@post.errors.any?</code> y en caso que los haya mostramos una lista de todos
los errores con <code>@post.errors.full_messages</code>.</p>
<p><code>pluralize</code> es un asistente de Rails que toma un número, un texto y sus argumentos.
Si el número es mayor de 1, el texto será automáticamente pluralizado</p>
<p>La razón de porque agregamos<code>@post = Post.new</code> en <code>posts_controller</code> es que de otra
manera <code>@post</code> será <code>nil</code> en tu vista y llamar a
<code>@post.errors.any?</code> mostrará un error.</p>
<p>CONSEJO: Rails automaticamente ajustará los campos que contienen error en un <code>div</code>
dentro de la clase <code>field_with_errors</code>. Puedes definir una regla <code>css</code>para destacarlos.</p>
<p>Ahora enviarás un bonito mensaje de error cuando intentes guardar un artículo sin título
en <a href="http://localhost:3000/posts/new" target="_blank">new post form (http://localhost:3000/posts/new)</a>.</p>
<p><img src="http://edgeguides.rubyonrails.org/images/getting_started/form_with_errors.png" alt="Form With Errors"></p>
<h3 id="actualizando-art-culos">Actualizando artículos</h3>
<p>Hemos cubierto la parte &quot;CR&quot; del acrónimo CRUD. Ahora nos enfocaremos en la parte &quot;U&quot;, actualización
de artículos.</p>
<p>El primer paso será agregar la acción <code>edit</code> al <code>posts_controller</code>.</p>
<p>Empecemos agregando una ruta a <code>config/routes.rb</code>:</p>
<pre><code class="lang-ruby">get <span class="hljs-string">"posts/:id/edit"</span> =&gt; <span class="hljs-string">"posts#edit"</span>
</code></pre>
<p>Y luego agregar la acción al controlador:</p>
<pre><code class="lang-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> </span>edit
  <span class="hljs-variable">@post</span> = <span class="hljs-constant">Post</span>.find(params[<span class="hljs-symbol">:id</span>])
<span class="hljs-keyword">end</span>
</code></pre>
<p>La vista contendrá un formulario similar al que usamos cuando creamos
nuevos artículos. Crea un archivo llamado <code>app/views/posts/edit.html.erb</code> que contenga
lo siguiente:</p>
<pre><code class="lang-html+erb">&lt;h1&gt;Editing post&lt;/h1&gt;

&lt;%= form_for :post, :url =&gt; { :action =&gt; :update, :id =&gt; @post.id },
:method =&gt; :put do |f| %&gt;
  &lt;% if @post.errors.any? %&gt;
  &lt;div id=&quot;errorExplanation&quot;&gt;
    &lt;h2&gt;&lt;%= pluralize(@post.errors.count, &quot;error&quot;) %&gt; prohibited
      this post from being saved:&lt;/h2&gt;
    &lt;ul&gt;
    &lt;% @post.errors.full_messages.each do |msg| %&gt;
      &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
    &lt;% end %&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
  &lt;% end %&gt;
  &lt;p&gt;
    &lt;%= f.label :title %&gt;&lt;br&gt;
    &lt;%= f.text_field :title %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= f.label :text %&gt;&lt;br&gt;
    &lt;%= f.text_area :text %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= f.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;

&lt;%= link_to &#39;Back&#39;, :action =&gt; :index %&gt;
</code></pre>
<p>Esta vez indicamos al formulario la acción <code>update</code>, la cual no está definido aún
pero pronto lo estará.</p>
<p>La opción <code>:method =&gt; :put</code> le dice a Rails que queremos que este formulario sea enviado
a través del método HTTP <code>PUT</code>, el cual es el método que tú esperas que se use para
<strong>actualizar</strong> recursos de acuerdo al protocolo REST.</p>
<p>CONSEJO: Por omisión los formularios construidos con el asistente <code>+form_for_</code> son enviados
a través de <code>POST</code>.</p>
<p>A continuación, necesitamos agregar la acción <code>update</code>. El archivo
<code>config/routes.rb</code> necesitará una línea más:</p>
<pre><code class="lang-ruby">put <span class="hljs-string">"posts/:id"</span> =&gt; <span class="hljs-string">"posts#update"</span>
</code></pre>
<p>Y luego crear la acción <code>update</code> en <code>app/controllers/posts_controller.rb</code>:</p>
<pre><code class="lang-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> </span>update
  <span class="hljs-variable">@post</span> = <span class="hljs-constant">Post</span>.find(params[<span class="hljs-symbol">:id</span>])

  <span class="hljs-keyword">if</span> <span class="hljs-variable">@post</span>.update_attributes(params[<span class="hljs-symbol">:post</span>])
    redirect_to <span class="hljs-symbol">:action</span> =&gt; <span class="hljs-symbol">:show</span>, <span class="hljs-symbol">:id</span> =&gt; <span class="hljs-variable">@post</span>.id
  <span class="hljs-keyword">else</span>
    render <span class="hljs-string">'edit'</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>El nuevo método <code>update_attributes</code>, es usado cuando deseas acualizar un registro
que ya existe, y acepta un hash conteniendo los atributos que deseas actualizar.
Como hicimos anteriormente, si hay un error actualizando el artículo queremos
mostrar el formulario de regreso al usuario.</p>
<p>CONSEJO: no necesitas enviar todos los atributos a <code>update_attributes</code>. Por
ejemplo, si llamas a <code>@post.update_attributes(:title =&gt; &#39;A new title&#39;)</code>
Rails solo actualizará el atributo <code>title</code> sin tocar los otros atributos.</p>
<p>Finalmente, queremos mostrar un enlace a la acción <code>edit</code> en la lista de todos
los artículos, de esta manera hacemos que ahora en <code>app/views/posts/index.html.erb</code>
aparezca un nuevo enlace adicional al enlace &quot;Show&quot;:</p>
<pre><code class="lang-html+erb">&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Title&lt;/th&gt;
    &lt;th&gt;Text&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @posts.each do |post| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= post.title %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= post.text %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to &#39;Show&#39;, :action =&gt; :show, :id =&gt; post.id %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to &#39;Edit&#39;, :action =&gt; :edit, :id =&gt; post.id %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;
</code></pre>
<p>Y también la agregaremos en la plantilla <code>app/views/posts/show.html.erb</code> de manera que
haya un enlace &quot;Edit&quot; en la página del artículo. Agregar esto al final de tu plantilla:</p>
<pre><code class="lang-html+erb">...

&lt;%= link_to &#39;Back&#39;, :action =&gt; :index %&gt;
| &lt;%= link_to &#39;Edit&#39;, :action =&gt; :edit, :id =&gt; @post.id %&gt;
</code></pre>
<p>Y así es como nuestra aplicación se ve hasta el momento</p>
<p><img src="http://edgeguides.rubyonrails.org/images/getting_started/index_action_with_edit_link.png" alt="Index action with edit link"></p>
<h3 id="usando-parciales-para-eliminar-la-duplicidad-en-las-vistas">Usando parciales para eliminar la duplicidad en las vistas</h3>
<p><code>partials</code> son lo que Rails usa para remover la duplicidad en las vistas. Aquí hay
un ejemplo:</p>
<pre><code class="lang-html+erb"># app/views/user/show.html.erb

&lt;h1&gt;&lt;%= @user.name %&gt;&lt;/h1&gt;

&lt;%= render &#39;user_details&#39; %&gt;

# app/views/user/_user_details.html.erb

&lt;%= @user.location %&gt;

&lt;%= @user.about_me %&gt;
</code></pre>
<p>La plantilla <code>users/show</code> automáticamente incluirá el contenido de la plantilla
<code>users/_user_details</code>. Nota que los parciales tienen como prefijo un subrayado,
de manera de no confundirlas con vistas regulares. Sin embargo, no incluyas
el subrayado cuando las incluyas dentro del método <code>helper</code>.</p>
<p>CONSEJO: Puedes leer más acerca de parciales en la guía
<a href="layouts_and_rendering.html">Layouts and Rendering in Rails</a>.</p>
<p>Nuestra acción <code>edit</code> parece muy similar a la acción <code>new</code>, en efecto ellos
comparten el mismo código para mostrar el formulario. Vamos a limpiarlo
usando un parcial.</p>
<p>Crea un nuevo archivo <code>app/views/posts/_form.html.erb</code> con el siguiente contenido:</p>
<pre><code class="lang-html+erb">&lt;%= form_for @post do |f| %&gt;
  &lt;% if @post.errors.any? %&gt;
  &lt;div id=&quot;errorExplanation&quot;&gt;
    &lt;h2&gt;&lt;%= pluralize(@post.errors.count, &quot;error&quot;) %&gt; prohibited
      this post from being saved:&lt;/h2&gt;
    &lt;ul&gt;
    &lt;% @post.errors.full_messages.each do |msg| %&gt;
      &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
    &lt;% end %&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
  &lt;% end %&gt;
  &lt;p&gt;
    &lt;%= f.label :title %&gt;&lt;br&gt;
    &lt;%= f.text_field :title %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= f.label :text %&gt;&lt;br&gt;
    &lt;%= f.text_area :text %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= f.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;
</code></pre>
<p>Todo, excepto la declaración <code>form_for</code> permanece igual. Como <code>form_for</code>
puede averiguar la <code>action</code> y los atributos del <code>method</code> correcto
cuando construye el formulario será explicado eun unos momentos.
Por ahora, vamos a actualizar la vista
<code>app/views/posts/new.html.erb</code> para usar el nuevo parcial, reescribiendo completamente:</p>
<pre><code class="lang-html+erb">&lt;h1&gt;New post&lt;/h1&gt;

&lt;%= render &#39;form&#39; %&gt;

&lt;%= link_to &#39;Back&#39;, :action =&gt; :index %&gt;
</code></pre>
<p>Luego hacer lo mismo a la vista <code>app/views/posts/edit.html.erb</code>:</p>
<pre><code class="lang-html+erb">&lt;h1&gt;Edit post&lt;/h1&gt;

&lt;%= render &#39;form&#39; %&gt;

&lt;%= link_to &#39;Back&#39;, :action =&gt; :index %&gt;
</code></pre>
<p>Ve con tu navegador a <a href="http://localhost:3000/posts/new" target="_blank">http://localhost:3000/posts/new</a> y
trata de crear un nuevo artículo. Todo funciona todavía, Ahora tratemos de editar el
artículo y recibiremos el siguiente mensaje de error:</p>
<p><img src="http://edgeguides.rubyonrails.org/images/getting_started/undefined_method_post_path.png" alt="Undefined method post_path"></p>
<p>Para entender este error necesitamos conocer como funciona <code>form_for</code>.
Cuando pasas un objeto a <code>form_for</code> y no especificas la opción de <code>:url</code>,
Rails trata de adivinar las opciones de <code>action</code> y <code>method</code> verificando
si el objeto pasado es un nuevo registro o no. Rails sigue la convencion
REST, de esta manera si se está creando un nuevo objeto <code>Post</code> buscará por una
ruta llamada <code>post_path</code> y para actualizar un objeto <code>Post</code> buscará por una
ruta llamada <code>post_path</code> y le pasará el objeto actual. Similarmente, Rails conoce
que debe crear nuevos objetos a través de POST y actualizarlos a través de PUT.</p>
<p>Si ejecutas <code>rake routes</code> desde la consola verás que ya tenemos una ruta
<code>posts_path</code>, la cual fue creada automáticamente por Rails cuando se definió la ruta
por la acción <code>index</code>. Sin embargo, no tenemos aún un <code>post_path</code>, la cual es la
razón por la que recibimos el error anterior.</p>
<pre><code class="lang-bash"><span class="hljs-comment"># rake routes</span>

    posts GET  /posts(.:format)            posts<span class="hljs-comment">#index</span>
posts_new GET  /posts/new(.:format)        posts<span class="hljs-comment">#new</span>
          POST /posts(.:format)            posts<span class="hljs-comment">#create</span>
          GET  /posts/:id(.:format)        posts<span class="hljs-comment">#show</span>
          GET  /posts/:id/edit(.:format)   posts<span class="hljs-comment">#edit</span>
          PUT  /posts/:id(.:format)        posts<span class="hljs-comment">#update</span>
     root      /                           welcome<span class="hljs-comment">#index</span>
</code></pre>
<p>Para arreglar eso, abrimos el archivo <code>config/routes.rb</code> y modificamos la línea <code>get &quot;posts/:id&quot;</code>
a esto:</p>
<pre><code class="lang-ruby">get <span class="hljs-string">"posts/:id"</span> =&gt; <span class="hljs-string">"posts#show"</span>, <span class="hljs-symbol">:as</span> =&gt; <span class="hljs-symbol">:post</span>
</code></pre>
<p>La opción <code>:as</code> le dice al método <code>get</code> que queremos hacer que los asistentes
de ruteo llamados <code>post_url</code> y <code>post_path</code> estén disponibles para nuestra aplicación.
Estos son los métodos que <code>form_for</code> necesita cuando estamos editando un artículo y que ahora
están disponibles para actualizar los artículos.</p>
<p>NOTA: La opción <code>:as</code> esta disponible también en los métodos de ruteo
<code>post</code>, <code>put</code>, <code>delete</code> y <code>match</code>.</p>
<h3 id="eliminando-art-culos">Eliminando artículos</h3>
<p>Ahora estamos listos para cubrir la parte &quot;D&quot; del acrónimo CRUD: eliminar artículos
en la base de datos. Siguiendo la convención REST, vamos a agregar una ruta para la
eliminación de artículos a <code>config/routes.rb</code>:</p>
<pre><code class="lang-ruby">delete <span class="hljs-string">"posts/:id"</span> =&gt; <span class="hljs-string">"posts#destroy"</span>
</code></pre>
<p>El método de enrutamiento <code>delete</code> debe ser usado para métodos que destruyen recursos.
Si se deja como un típico comando de ruteo <code>get</code>, es posible que se puedan enviar
URLs malintencionadas como estas:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">'http://yoursite.com/posts/1/destroy'</span>&gt;</span>look at this cat!<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
</code></pre>
<p>Nosotros usamos el método <code>delete</code> para destruir recursos y este ruteo está enlazado
con la acción <code>destroy</code> dentro de <code>app/controllers/posts_controller.rb</code>, la cual no existe
aún pero que se muestra a continuación:</p>
<pre><code class="lang-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> </span>destroy
  <span class="hljs-variable">@post</span> = <span class="hljs-constant">Post</span>.find(params[<span class="hljs-symbol">:id</span>])
  <span class="hljs-variable">@post</span>.destroy

  redirect_to <span class="hljs-symbol">:action</span> =&gt; <span class="hljs-symbol">:index</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Puedes llamar a <code>destroy</code> en objetos Active Record cuando desees eliminarlos de la
base de datos. Hay que tener en cuenta que no necesitas agregar una vista para esta acción ya que
estamos siendo redireccionados a la acción <code>index</code>.</p>
<p>Finalmente, agregamos un enlace a la plantilla de la acción <code>index</code>
(<code>app/views/posts/index.html.erb</code>) para completar todo.</p>
<pre><code class="lang-html+erb">&lt;h1&gt;Listing Posts&lt;/h1&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Title&lt;/th&gt;
    &lt;th&gt;Text&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @posts.each do |post| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= post.title %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= post.text %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to &#39;Show&#39;, :action =&gt; :show, :id =&gt; post.id %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to &#39;Edit&#39;, :action =&gt; :edit, :id =&gt; post.id %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to &#39;Destroy&#39;, { :action =&gt; :destroy, :id =&gt; post.id }, :method =&gt; :delete, :data =&gt; { :confirm =&gt; &#39;Are you sure?&#39; } %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;
</code></pre>
<p>Usaremos aquí <code>link_to</code> de diferente manera. Empaquetaremos los atributos
<code>:action</code> y <code>:id</code> en un hash de manera que podamos pasar las dos claves como uno
en un solo argumento y finalmente las otras dos claves como otro argumento.
Las opciones <code>:method</code> y <code>:&#39;data-confirm&#39;</code> son usadas como atributos HTML de manera de que cuando
se hace clic en el enlace Rails mostrará un diálogo de confirmación al usuario
y luego direccionará al enlace con el método <code>delete</code>.
Esto es realizado a través de un archivo JavaScript <code>jquery_ujs</code> el cual fue automáticamente
incluido dentro del diseño de tu aplicación (<code>app/views/layouts/application.html.erb</code>) cuando
la aplicación fue generada. Sin este archivo el diálogo de confirmación no aparecerá.</p>
<p><img src="http://edgeguides.rubyonrails.org/images/getting_started/confirm_dialog.png" alt="Confirm Dialog"></p>
<p>Felicitaciones, ahora puedes crear, mostrar, enumerar, actualizar y eliminar
artículos. En la siguiente sección veremos cómo Rails puede ayudarnos en la creación de
aplicaciones REST, y cómo podemos refactorizar nuestro Blog  para tomar
ventaja de ello.</p>
<h3 id="profundizando-en-rest">Profundizando en REST</h3>
<p>Ya hemos cubierto todas las acciones CRUD de una aplicación REST.
Lo hicimos declarando rutas separadas con los verbos adecuados en
<code>config/routes.rb</code>. Así es como se ve el archivo hasta ahora:</p>
<pre><code class="lang-ruby">get <span class="hljs-string">"posts"</span> =&gt; <span class="hljs-string">"posts#index"</span>
get <span class="hljs-string">"posts/new"</span>
post <span class="hljs-string">"posts"</span> =&gt; <span class="hljs-string">"posts#create"</span>
get <span class="hljs-string">"posts/:id"</span> =&gt; <span class="hljs-string">"posts#show"</span>, <span class="hljs-symbol">:as</span> =&gt; <span class="hljs-symbol">:post</span>
get <span class="hljs-string">"posts/:id/edit"</span> =&gt; <span class="hljs-string">"posts#edit"</span>
put <span class="hljs-string">"posts/:id"</span> =&gt; <span class="hljs-string">"posts#update"</span>
delete <span class="hljs-string">"posts/:id"</span> =&gt; <span class="hljs-string">"posts#destroy"</span>
</code></pre>
<p>Eso es un montón de código para cubrir un único <strong>recurso</strong>. Afortunadamente,
Rails proporciona un método llamado <code>resources</code> el cual puede ser usado para
declarar un recurso REST estándar. Así es como el archivo <code>config/routes.rb</code>
se ve luego de utilizar <code>resources</code>:</p>
<pre><code class="lang-ruby"><span class="hljs-constant">Blog::Application</span>.routes.draw <span class="hljs-keyword">do</span>

  resources <span class="hljs-symbol">:posts</span>

  root <span class="hljs-symbol">:to</span> =&gt; <span class="hljs-string">"welcome#index"</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Si ejecutas <code>rake routes</code>, podrás ver que todas las rutas que
declaramos anteriormente aún están disponibles:</p>
<pre><code class="lang-bash"><span class="hljs-comment"># rake routes</span>
    posts GET    /posts(.:format)          posts<span class="hljs-comment">#index</span>
          POST   /posts(.:format)          posts<span class="hljs-comment">#create</span>
 new_post GET    /posts/new(.:format)      posts<span class="hljs-comment">#new</span>
edit_post GET    /posts/:id/edit(.:format) posts<span class="hljs-comment">#edit</span>
     post GET    /posts/:id(.:format)      posts<span class="hljs-comment">#show</span>
          PUT    /posts/:id(.:format)      posts<span class="hljs-comment">#update</span>
          DELETE /posts/:id(.:format)      posts<span class="hljs-comment">#destroy</span>
     root        /                         welcome<span class="hljs-comment">#index</span>
</code></pre>
<p>Además, si vas a través de las acciones de creación, actualización
y eliminación de posts, la aplicación sigue funcionando como antes.</p>
<p>TIP: En general, Rails fomenta el uso de recursos (<code>resources</code>) en lugar
de declarar las rutas manualmente. Se hizo solamente en esta guía como
un ejercicio de aprendizaje. Para más información acerca de <em>routing</em>,
mira <a href="http://guides.rubyonrails.org/routing.html" target="_blank">Rails Routing from the Outside In</a>.</p>
<h2 id="agregando-un-segundo-modelo">Agregando un Segundo Modelo</h2>
<p>Es hora de agregar un segundo modelo a la aplicación. El segundo modelo debe
manejar los comentarios de los artículos.</p>
<h3 id="generando-un-modelo">Generando un Modelo</h3>
<p>Vamos a usar el mismo generador que usamos antes al crear el modelo <code>Post</code>. Esta
vez crearemos el modelo <code>Comment</code> para los comentarios del artículo. Ejecuta
esto en tu terminal:</p>
<pre><code class="lang-bash">$ rails generate model Comment commenter:string body:text post:references
</code></pre>
<p>Este comando generará cuatro archivos:</p>
<table>
<thead>
<tr>
<th>Archivo</th>
<th>Propósito</th>
</tr>
</thead>
<tbody>
<tr>
<td>db/migrate/20100207235629_create_comments.rb</td>
<td>Migración para crear la tabla de comentarios en tu base de datos (en tu caso con un timestamp diferente).</td>
</tr>
<tr>
<td>app/models/comment.rb</td>
<td>El modelo Comment.</td>
</tr>
<tr>
<td>test/unit/comment_test.rb</td>
<td>Prubas unitarias para el modelo de comentarios.</td>
</tr>
<tr>
<td>test/fixtures/comments.yml</td>
<td>Muestras de comentarios para usar de pruebas.</td>
</tr>
</tbody>
</table>
<p>Primero, miremos <code>comment.rb</code>:</p>
<pre><code class="lang-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comment</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">ActiveRecord::Base</span></span></span>
  belongs_to <span class="hljs-symbol">:post</span>
  attr_accessible <span class="hljs-symbol">:body</span>, <span class="hljs-symbol">:commenter</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Ésto es muy similar al modelo <code>post.rb</code> que vimos antes. La diferencia es la
línea <code>belongs_to :post</code>, que establece una asociación de Active Record.
Vas a aprender un poco más sobre asociaciones en la siguiente sección de esta
guía.</p>
<p>Además del modelo, Rails hizo la migración para crear la tabla correspondiente
en la base de datos:</p>
<pre><code class="lang-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateComments</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">ActiveRecord::Migration</span></span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> </span>change
    create_table <span class="hljs-symbol">:comments</span> <span class="hljs-keyword">do</span> |t|
      t.string <span class="hljs-symbol">:commenter</span>
      t.text <span class="hljs-symbol">:body</span>
      t.references <span class="hljs-symbol">:post</span>

      t.timestamps
    <span class="hljs-keyword">end</span>

    add_index <span class="hljs-symbol">:comments</span>, <span class="hljs-symbol">:post_id</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>La línea <code>t.references</code> establece una columna <em>foreign key</em> para la asociación
entre los dos modelos. La línea <code>add_index</code> establece un index para esta columna
de la asociación. Corre la migración:</p>
<pre><code class="lang-bash">$ rake db:migrate
</code></pre>
<p>Rails es suficientemente listo para sólo ejecutar las migraciones que no se han
ejecutado todavía en la base de datos actual, así que en este caso sólo verás:</p>
<pre><code class="lang-bash">==  CreateComments: migrating =================================================
-- create_table(:comments)
   -&gt; <span class="hljs-number">0.0008</span>s
-- add_index(:comments, :post_id)
   -&gt; <span class="hljs-number">0.0003</span>s
==  CreateComments: migrated (<span class="hljs-number">0.0012</span>s) ========================================
</code></pre>
<h3 id="asociando-modelos">Asociando Modelos</h3>
<p>Las asociaciones de Active Record te permiten declarar fácilmente la relación
entre dos modelos. En el caso de los comentarios y artículos, puedes escribir la
relación de esta manera:</p>
<ul>
<li>Cada comentario pertence a un artículo.</li>
<li>Un artículo puede tener muchos comentarios.</li>
</ul>
<p>De hecho, ésto es muy cercano a la sintáxis que usa Rails para declarar esta
asociación. Ya has visto la línea de código en el modelo <code>Comment</code> que hace que
cada comentario pertenezca a un artículo:</p>
<pre><code class="lang-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comment</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">ActiveRecord::Base</span></span></span>
  belongs_to <span class="hljs-symbol">:post</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Vas a tener que editar el archivo <code>post.rb</code> para agregar el otro lado de la
asociación:</p>
<pre><code class="lang-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Post</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">ActiveRecord::Base</span></span></span>
  validates <span class="hljs-symbol">:title</span>, <span class="hljs-symbol">:presence</span> =&gt; <span class="hljs-keyword">true</span>,
                    <span class="hljs-symbol">:length</span> =&gt; { <span class="hljs-symbol">:minimum</span> =&gt; <span class="hljs-number">5</span> }

  has_many <span class="hljs-symbol">:comments</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Estas dos declaraciones permiten bastante comportamiento automatizado. Por
ejemplo, si tienes una variable de instancia <code>@post</code> conteniendo un artículo,
puedes obtener todos los comentarios que pertenecen a ese artículo como un
arreglo usando <code>@post.comments</code>.</p>
<p>SUGERENCIA: Para más información sobre las asociaciones de Active Record, revisa
la guía <a href="http://guides.rubyonrails.org/association_basics.html" target="_blank">Active Record Associations</a>
(en inglés).</p>
<h3 id="agregando-una-ruta-para-comentarios">Agregando una Ruta para Comentarios</h3>
<p>Así como con el controlador <code>welcome</code>, vamos a necesitar agregar una ruta para
que Rails sepa donde queremos navegar para ver <code>comments</code>. Abre el archivo
<code>config/routes.rb</code> nuevamente, y edítalo de la siguiente manera:</p>
<pre><code class="lang-ruby">resources <span class="hljs-symbol">:posts</span> <span class="hljs-keyword">do</span>
  resources <span class="hljs-symbol">:comments</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Ésto crea <code>comments</code> como un <em>recurso anidado</em> dentro de <code>posts</code>. Esta es otra
parte de capturar la relación jerárquica que existe entre artículos y
comentarios.</p>
<p>SUGERENCIA: Para más información sobre el ruteo, mira la guía
<a href="http://guides.rubyonrails.org/routing.html" target="_blank">Rails Routing from the Outside In</a>
(en inglés).</p>
<h3 id="generando-un-controlador">Generando un Controlador</h3>
<p>Con el modelo terminado, necesitamos crearle un controlador. Nuevamente,
usaremos el mismo generador que antes:</p>
<pre><code class="lang-bash">$ rails generate controller Comments
</code></pre>
<p>Esto crea seis diferentes archivos y una carpeta vacía:</p>
<table>
<thead>
<tr>
<th>Archivo/Carpeta</th>
<th>Propósito</th>
</tr>
</thead>
<tbody>
<tr>
<td>app/controllers/comments_controller.rb</td>
<td>El controlador de Comments.</td>
</tr>
<tr>
<td>app/views/comments/</td>
<td>Donde se guardan las vistas del controlador.</td>
</tr>
<tr>
<td>test/functional/comments_controller_test.rb</td>
<td>Las pruebas funcionales del controlador.</td>
</tr>
<tr>
<td>app/helpers/comments_helper.rb</td>
<td>El helper de la vista.</td>
</tr>
<tr>
<td>test/unit/helpers/comments_helper_test.rb</td>
<td>Las pruebas unitarias para el helper.</td>
</tr>
<tr>
<td>app/assets/javascripts/comment.js.coffee</td>
<td>CoffeeScript para el controlador.</td>
</tr>
<tr>
<td>app/assets/stylesheets/comment.css.scss</td>
<td>Hojas de estilo para el controlador.</td>
</tr>
</tbody>
</table>
<p>Como con cualquier blog, nuestros lectores crearán sus comentarios directamente
después de leer el artículo, y una vez que agregaron su comentario, serán
enviados de vuelta al artículo para ver su comentario ahora listado. Debido a
esto, nuestro <code>CommentsController</code> está ahí para proveer un método para crear
comentarios y eliminar spam cuando aparezca.</p>
<p>Así que primero, vamos a armar la plantilla <code>show</code> del artículo
(<code>/app/views/posts/show.html.erb</code>) para que nos permita hacer comentarios:</p>
<pre><code class="lang-html+erb">&lt;p&gt;
  &lt;strong&gt;Title:&lt;/strong&gt;
  &lt;%= @post.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Text:&lt;/strong&gt;
  &lt;%= @post.text %&gt;
&lt;/p&gt;

&lt;h2&gt;Add a comment:&lt;/h2&gt;
&lt;%= form_for([@post, @post.comments.build]) do |f| %&gt;
  &lt;p&gt;
    &lt;%= f.label :commenter %&gt;&lt;br /&gt;
    &lt;%= f.text_field :commenter %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.label :body %&gt;&lt;br /&gt;
    &lt;%= f.text_area :body %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;

&lt;%= link_to &#39;Edit Post&#39;, edit_post_path(@post) %&gt; |
&lt;%= link_to &#39;Back to Posts&#39;, posts_path %&gt;
</code></pre>
<p>Ésto agrega un formulario en la vista <code>show</code> del artítculo que crea un
comentario al llamar a la acción <code>create</code> en el <code>CommentsController</code>. Al llamar
<code>form_for</code> se necesita pasar un arreglo, que construirá una ruta anidada,
siguiendo el esquema <code>/posts/1/comments</code>.</p>
<p>Armemos la acción <code>create</code>:</p>
<pre><code class="lang-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommentsController</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">ApplicationController</span></span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> </span>create
    <span class="hljs-variable">@post</span> = <span class="hljs-constant">Post</span>.find(params[<span class="hljs-symbol">:post_id</span>])
    <span class="hljs-variable">@comment</span> = <span class="hljs-variable">@post</span>.comments.create(params[<span class="hljs-symbol">:comment</span>])
    redirect_to post_path(<span class="hljs-variable">@post</span>)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Verás un poco más de complejidad aquí comparado a lo visto en el controlador de
artículos. Eso es un efecto secundario del anidado que estás usando. Cada vez
que se crea un comentario es necesario saber a que artículo pertenece. Por eso
la primera llamada al método <code>find</code> del modelo <code>Post</code>, para ubicar el artículo
en particular.</p>
<p>Además, el código trata de tomar ventaja de algunos de los métodos disponibles
a las asociaciones. Usamos el método <code>create</code> en <code>@post.comments</code> para crear y
guardar el comentario. Esto asociará automaticamente el comentario el artículo
en particular.</p>
<p>Una vez que hemos hecho el comentario nuevo, enviamos al usuario de vuelta al
artículo original usando el helper <code>post_path(@post)</code>. Como hemos podido ver,
ésto luego llama a la acción <code>show</code> en el <code>PostsController</code> que hace render con
la plantilla <code>show.html.erb</code>. Aquí es donde queremos mostrar los comentarios,
así que agreguemos <code>app/views/posts/show.html.erb</code>.</p>
<pre><code class="lang-html+erb">&lt;p&gt;
  &lt;strong&gt;Title:&lt;/strong&gt;
  &lt;%= @post.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Text:&lt;/strong&gt;
  &lt;%= @post.text %&gt;
&lt;/p&gt;

&lt;h2&gt;Comments&lt;/h2&gt;
&lt;% @post.comments.each do |comment| %&gt;
  &lt;p&gt;
    &lt;strong&gt;Commenter:&lt;/strong&gt;
    &lt;%= comment.commenter %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;strong&gt;Comment:&lt;/strong&gt;
    &lt;%= comment.body %&gt;
  &lt;/p&gt;
&lt;% end %&gt;

&lt;h2&gt;Add a comment:&lt;/h2&gt;
&lt;%= form_for([@post, @post.comments.build]) do |f| %&gt;
  &lt;p&gt;
    &lt;%= f.label :commenter %&gt;&lt;br /&gt;
    &lt;%= f.text_field :commenter %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.label :body %&gt;&lt;br /&gt;
    &lt;%= f.text_area :body %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;

&lt;%= link_to &#39;Edit Post&#39;, edit_post_path(@post) %&gt; |
&lt;%= link_to &#39;Back to Posts&#39;, posts_path %&gt;
</code></pre>
<p>Ahora puedes agregar artículos y comentarios a tu blog, y hacer que se muestren
en los lugares correctos.</p>
<p><img src="http://edgeguides.rubyonrails.org/images/getting_started/post_with_comments.png" alt="Artículo con Comentarios"></p>
<h2 id="haciendo-refactoring">Haciendo Refactoring</h2>
<p>Ahora que tenemos los artículos y comentarios funcionando, dale una mirada a la
plantilla <code>app/views/posts/show.html.erb</code>. Se está volviendo larga y complicada.
Podemos usar parciales (<em>partials</em>) para simplificarla.</p>
<h3 id="haciendo-render-de-colecciones-de-parciales">Haciendo Render de Colecciones de Parciales</h3>
<p>Primero, creemos el parcial de comentario para extraer el mostrar de todos los
comentarios del artículo. Crea el archivo <code>app/views/comments/_comment.html.erb</code>
y coloca lo siguiente:</p>
<pre><code class="lang-html+erb">&lt;p&gt;
  &lt;strong&gt;Commenter:&lt;/strong&gt;
  &lt;%= comment.commenter %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Comment:&lt;/strong&gt;
  &lt;%= comment.body %&gt;
&lt;/p&gt;
</code></pre>
<p>Luego puedes cambiar <code>app/views/posts/show.html.erb</code> para que se vea de esta
manera:</p>
<pre><code class="lang-html+erb">&lt;p&gt;
  &lt;strong&gt;Title:&lt;/strong&gt;
  &lt;%= @post.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Text:&lt;/strong&gt;
  &lt;%= @post.text %&gt;
&lt;/p&gt;

&lt;h2&gt;Comments&lt;/h2&gt;
&lt;%= render @post.comments %&gt;

&lt;h2&gt;Add a comment:&lt;/h2&gt;
&lt;%= form_for([@post, @post.comments.build]) do |f| %&gt;
  &lt;p&gt;
    &lt;%= f.label :commenter %&gt;&lt;br /&gt;
    &lt;%= f.text_field :commenter %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.label :body %&gt;&lt;br /&gt;
    &lt;%= f.text_area :body %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;

&lt;%= link_to &#39;Edit Post&#39;, edit_post_path(@post) %&gt; |
&lt;%= link_to &#39;Back to Posts&#39;, posts_path %&gt;
</code></pre>
<p>Ésto hará que el parcial en <code>app/views/comments/_comment.html.erb</code> se haga
render una vez por cada comentario en la colección <code>@post.comments</code>. A medida
que el método <code>render</code> itera sobre la colección <code>@post.comments</code>, asigna cada
comentario a la variable local llamada igual que el parcial, en este caso
<code>comment</code> que luego está disponible en el parcial para que la usemos.</p>
<h3 id="haciendo-render-de-un-parcial-de-formulario">Haciendo Render de un Parcial de Formulario</h3>
<p>Movamos también la sección de comentarios nuevos a su propio parcial. De nuevo,
crea un archivo <code>app/views/comments/_form.html.erb</code> que contenga:</p>
<pre><code class="lang-html+erb">&lt;%= form_for([@post, @post.comments.build]) do |f| %&gt;
  &lt;p&gt;
    &lt;%= f.label :commenter %&gt;&lt;br /&gt;
    &lt;%= f.text_field :commenter %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.label :body %&gt;&lt;br /&gt;
    &lt;%= f.text_area :body %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;
</code></pre>
<p>Luego haz que <code>app/views/posts/show.html.erb</code> se vea de la siguiente manera:</p>
<pre><code class="lang-html+erb">&lt;p&gt;
  &lt;strong&gt;Title:&lt;/strong&gt;
  &lt;%= @post.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Text:&lt;/strong&gt;
  &lt;%= @post.text %&gt;
&lt;/p&gt;

&lt;h2&gt;Add a comment:&lt;/h2&gt;
&lt;%= render &quot;comments/form&quot; %&gt;

&lt;%= link_to &#39;Edit Post&#39;, edit_post_path(@post) %&gt; |
&lt;%= link_to &#39;Back to Posts&#39;, posts_path %&gt;
</code></pre>
<p>El segundo render sólo define la plantilla parcial que queremos usar,
<code>comments/form</code>. Rails es suficientemente inteligente para detectar el slash en
el texto y darse cuenta que lo que quieres es hacer render del archivo
<code>_form.html.erb</code> en la carpeta <code>app/views/comments</code>.</p>
<p>El objeto <code>@post</code> está disponible a cualquier parcial al que se le haga render
en la vista porque lo hemos definido como una variable de instancia.</p>
<h2 id="eliminando-comentarios">Eliminando Comentarios</h2>
<p>Otra funcionalidad importante para un blog es poder eliminar comentarios spam.
Para hacer esto, necesitamos implementar un enlace de algún tipo en la vista, y
una acción <code>DELETE</code> en el <code>CommentsController</code>.</p>
<p>Primero, agreguemos el enlace para eliminar en el parcial
<code>app/views/comments/_comment.html.erb</code>:</p>
<pre><code class="lang-html+erb">&lt;p&gt;
  &lt;strong&gt;Commenter:&lt;/strong&gt;
  &lt;%= comment.commenter %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Comment:&lt;/strong&gt;
  &lt;%= comment.body %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;%= link_to &#39;Eliminar Comentario&#39;, [comment.post, comment],
               :method =&gt; :delete,
               :data =&gt; { :confirm =&gt; &#39;¿Estás seguro?&#39; } %&gt;
&lt;/p&gt;
</code></pre>
<p>Al hacer click en este nuevo enlace &quot;Eliminar Comentario&quot; se enviará un <code>DELETE
/posts/:id/comments/:id</code> a nuestro <code>CommentsController</code>, que puede luego usar
para ubicar el comentario que queremos eliminar, así que agreguemos una acción
de eliminar a nuestro controlador:</p>
<pre><code class="lang-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommentsController</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">ApplicationController</span></span></span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> </span>create
    <span class="hljs-variable">@post</span> = <span class="hljs-constant">Post</span>.find(params[<span class="hljs-symbol">:post_id</span>])
    <span class="hljs-variable">@comment</span> = <span class="hljs-variable">@post</span>.comments.create(params[<span class="hljs-symbol">:comment</span>])
    redirect_to post_path(<span class="hljs-variable">@post</span>)
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> </span>destroy
    <span class="hljs-variable">@post</span> = <span class="hljs-constant">Post</span>.find(params[<span class="hljs-symbol">:post_id</span>])
    <span class="hljs-variable">@comment</span> = <span class="hljs-variable">@post</span>.comments.find(params[<span class="hljs-symbol">:id</span>])
    <span class="hljs-variable">@comment</span>.destroy
    redirect_to post_path(<span class="hljs-variable">@post</span>)
  <span class="hljs-keyword">end</span>

<span class="hljs-keyword">end</span>
</code></pre>
<p>La acción <code>destroy</code> encontrará el artículo que estamos viendo, luego el
comentario en la colección <code>@post.comments</code>, para eliminarlo de la base de datos
y enviarnos de vuelta a la acción <code>show</code> para el artículo.</p>
<h3 id="eliminando-objetos-asociados">Eliminando Objetos Asociados</h3>
<p>Si eliminas un artículo entonces sus comentarios asociados necesitas ser
eliminados también. Si no lo haces simplemente van a ocupar espacio en la base
de datos. Rails te permite usar la opción <code>dependent</code> en las asociaciones para
lograrlo. Modifica el modelo Post, en <code>app/models/post.rb</code>, de esta manera:</p>
<pre><code class="lang-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Post</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">ActiveRecord::Base</span></span></span>
  validates <span class="hljs-symbol">:title</span>, <span class="hljs-symbol">:presence</span> =&gt; <span class="hljs-keyword">true</span>,
                    <span class="hljs-symbol">:length</span> =&gt; { <span class="hljs-symbol">:minimum</span> =&gt; <span class="hljs-number">5</span> }
  has_many <span class="hljs-symbol">:comments</span>, <span class="hljs-symbol">:dependent</span> =&gt; <span class="hljs-symbol">:destroy</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2 id="seguridad">Seguridad</h2>
<p>Si fueras a publicar tu blog en línea, cualquier persona podría agregar, editar
y eliminar artículos o eliminar comentarios.</p>
<p>Rails provee un sistema muy simple de autenticación por HTTP que funcionaría muy
bien en esta situación.</p>
<p>Necesitamos una forma de bloquear el acceso a ciertas acciones en el controlador
<code>PostsController</code> si la persona no está autenticada, aquí podemos usar el método
de Rails <code>http_basic_authenticate_with</code>, que permite acceso a la acción
solicitada si el método retorna <code>true</code>.</p>
<p>Para usar el sistema de autenticación, lo especificamos en la parte inicial de
<code>PostsController</code>, en este caso, queremos autenticar al usuario en cada una de
las acciones, excepto <code>index</code> y <code>show</code>, así lo escribimos:</p>
<pre><code class="lang-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostsController</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">ApplicationController</span></span></span>

  http_basic_authenticate_with <span class="hljs-symbol">:name</span> =&gt; <span class="hljs-string">"dhh"</span>, <span class="hljs-symbol">:password</span> =&gt; <span class="hljs-string">"secret"</span>, <span class="hljs-symbol">:except</span> =&gt; [<span class="hljs-symbol">:index</span>, <span class="hljs-symbol">:show</span>]

  <span class="hljs-function"><span class="hljs-keyword">def</span> </span>index
    <span class="hljs-variable">@posts</span> = <span class="hljs-constant">Post</span>.all
<span class="hljs-comment"># cortado por brevedad</span>
</code></pre>
<p>También queremos limitar la eliminación de comentarios a los usuarios autenticados, así
que en <code>CommentsController</code> escribimos:</p>
<pre><code class="lang-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommentsController</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">ApplicationController</span></span></span>

  http_basic_authenticate_with <span class="hljs-symbol">:name</span> =&gt; <span class="hljs-string">"dhh"</span>, <span class="hljs-symbol">:password</span> =&gt; <span class="hljs-string">"secret"</span>, <span class="hljs-symbol">:only</span> =&gt; <span class="hljs-symbol">:destroy</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> </span>create
    <span class="hljs-variable">@post</span> = <span class="hljs-constant">Post</span>.find(params[<span class="hljs-symbol">:post_id</span>])
<span class="hljs-comment"># cortado por brevedad</span>
</code></pre>
<p>Ahora si intentamos crear un nuevo artículo, vas a ser recibido con una ventana
de diálogo de autenticación HTTP básica.</p>
<p><img src="http://edgeguides.rubyonrails.org/images/challenge.png" alt="Ventana de diálogo de autenticación HTTP básica"></p>
<h2 id="errores-comunes-de-configuraci-n">Errores Comunes de Configuración</h2>
<p>La forma más fácil de trabajar con Rails es guardando toda los datos externos
como UTF-8. Si no lo haces, por lo general las librerías de Ruby y Rails van a
ser capaces de convertir tus datos nativos a UTF-8, pero esto no funciona en
todos los casos, así que lo ideal es asegurarte que todos tus datos externos
usen UTF-8.</p>
<p>Si has cometido un error de este tipo, el síntoma más común es un símbolo de un
diamante negro con un signo de interrogación en vez de algunos caracteres en tu
navegador. Otro síntoma común es ver caracteres como &quot;Ã¼&quot; apareciendo en vez de
la &quot;ü&quot; por ejemplo. Rails realiza una serie de pasos internos para resolver
casos comunes. Sin embargo, si tienes datos externos que no están guardados en
UTF-8, puede resultar en este tipo de problemas al no ser automáticamente
detectados y resueltos por Rails.</p>
<p>Dos fuentes comunes de datos que no están en UTF-8:</p>
<ul>
<li>Tu editor de texto: La mayoría de editores de texto (como TextMate, o Sublime
Text), guardan los archivos en UTF-8 por defecto. Si tu editor no lo hace,
esto puede resultar en los problemas mencionados arriba. Esto también aplica
a los archivos de traducción para I18n. La mayoría de editores que no usan
UTF-8 por defecto (como algunas versionesde Dreamweaver) ofrecen una manera
para cambiar la opción por defecto a UTF-8. Házlo!</li>
<li>Tu base de datos. Rails convierte los datos que intercambia con tu base de
datos a UTF-8 por defecto. Sin embargo, si tu base de datos no está usando
UTF-8 internamente, puede no ser capaz de guardar todos los datos que ingresen
tus usuarios. Por ejemplo, si tu base de datos está usando Latin-1
internamente, y tus usuarios ingresan caracteres rusos, hebreos o japoneses,
esos datos serán perdidos para siempre una vez que entren a la base de datos.
Si es posible, usa UTF-8 internamente para el almacenamiento de datos.</li>
</ul>

                    
                    </section>
                
                </div>
            </div>
        </div>

        
        
        <a href="./capitulos/antes_de_empezar.html" class="navigation navigation-next navigation-unique" aria-label="Next page: Antes de empezar"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        

        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.1.3/ace.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.1.3/mode-javascript.js"></script>
        <script src="gitbook/jsrepl/jsrepl.js" id="jsrepl-script"></script>
        <script src="gitbook/app.js"></script>
        

    
    <script src="gitbook/plugins/gitbook-plugin-ga/plugin.js"></script>
    

<script>
require(["gitbook"], function(gitbook) {
    var config = {"ga":{"token":"TOKEN"}};
    gitbook.start(config);
});
</script>

    </body>
</html>
